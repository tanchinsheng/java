i1 == i2 will return false because both are pointing to different object.
i1 == i3 will return true because one operand is a primitive int and so the
other will be unboxed and then the value will be compared.
i1 == b1 will not even compile because type of i1 and b1 references are
classes that are not in the same class hierarchy.
 So == knows at compile time itself that they can't point to the same object.

i1.equals(i2) will return true because both are Integer objects and both
have the value 1.
i1.equals(b1) and i1.equals(g1) will return false because they are pointing
to objects of different types.
Signature of equals method is : boolean equals(Object o);
So it can take any object hence there will be no compilation error.
Further, The equals methods of all wrapper classes first check if the two
object are of same class or not.
If not, they immediately return false.
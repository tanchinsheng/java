It will print 0000 when run.

It will compile if class BankAccount provides an implementation for getId method.//true
//Since interface PremiumAccount redeclares getId method as abstract, the BankAccount class must either 
provide an implementation for this method or be marked as abstract. 
In this case, making the class abstract will not help because of the statement - Account acct = new BankAccount();

It will not compile unless interface PremiumAccount is marked abstract.
//Interfaces are always abstract. You can but you don't have to mark them abstract. 
Methods of an interface that are not marked default or static are also always abstract. 
You don't have to mark them as abstract.

It will compile if getId method in PremiumAccount is replaced with: public String getId(){ super.getId(); }
//You cannot use super keyword to call a method defined in the super interface.

It will compile if getId method in PremiumAccount is replaced with: public default String getId(){ super.getId(); }
//super.methodName(...) is a valid way to invoke a super class's method from anywhere within a subclass's method. 
But it works only for classes. You cannot invoke the interface's default method using this technique. 
In fact, if a class (or an interface) overrides a default method of an interface, 
there is no way to invoke that default method from that class (or interface).

It will compile if getId method in PremiumAccount is replaced with: public default String getId(){ super(); }
//super(); is used to invoke the super class's constructor. So, if present, it can only be the first statement of a constructor. 
Calling super(); does not invoke the super class's method.